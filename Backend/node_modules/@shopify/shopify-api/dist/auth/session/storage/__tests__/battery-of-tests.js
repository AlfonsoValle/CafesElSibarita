"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.batteryOfTests = void 0;
var tslib_1 = require("tslib");
var context_1 = require("../../../../context");
var session_1 = require("../../session");
var session_utils_1 = require("../../session-utils");
var session_test_utils_1 = require("./session-test-utils");
function batteryOfTests(storageFactory) {
    var _this = this;
    it('can store and delete all kinds of sessions', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var sessionFactories, sessionId, storage, sessionFactories_1, sessionFactories_1_1, factory, session, _a, _b, loadedSession, e_1_1;
        var e_1, _c;
        var _this = this;
        return tslib_1.__generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    sessionFactories = [
                        function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                            var session;
                            return tslib_1.__generator(this, function (_a) {
                                session = new session_1.Session(sessionId, 'shop', 'state', false);
                                session.scope = context_1.Context.SCOPES.toString();
                                session.accessToken = '123';
                                return [2 /*return*/, session];
                            });
                        }); },
                        function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                            var session, expiryDate;
                            return tslib_1.__generator(this, function (_a) {
                                session = new session_1.Session(sessionId, 'shop', 'state', false);
                                expiryDate = new Date();
                                expiryDate.setMinutes(expiryDate.getMinutes() + 60);
                                session.expires = expiryDate;
                                session.accessToken = '123';
                                session.scope = context_1.Context.SCOPES.toString();
                                return [2 /*return*/, session];
                            });
                        }); },
                        function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                            var session;
                            return tslib_1.__generator(this, function (_a) {
                                session = new session_1.Session(sessionId, 'shop', 'state', false);
                                session.expires = null;
                                session.scope = context_1.Context.SCOPES.toString();
                                session.accessToken = '123';
                                return [2 /*return*/, session];
                            });
                        }); },
                        function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                            var session;
                            return tslib_1.__generator(this, function (_a) {
                                session = new session_1.Session(sessionId, 'shop', 'state', false);
                                session.expires = undefined;
                                session.scope = context_1.Context.SCOPES.toString();
                                session.accessToken = '123';
                                return [2 /*return*/, session];
                            });
                        }); },
                        function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                            var session;
                            return tslib_1.__generator(this, function (_a) {
                                session = new session_1.Session(sessionId, 'shop', 'state', false);
                                // eslint-disable-next-line  @typescript-eslint/naming-convention
                                session.onlineAccessInfo = { associated_user: {} };
                                session.onlineAccessInfo.associated_user.id = 123;
                                session.scope = context_1.Context.SCOPES.toString();
                                session.accessToken = '123';
                                return [2 /*return*/, session];
                            });
                        }); },
                    ];
                    sessionId = 'test_session';
                    return [4 /*yield*/, storageFactory()];
                case 1:
                    storage = _d.sent();
                    _d.label = 2;
                case 2:
                    _d.trys.push([2, 14, 15, 16]);
                    sessionFactories_1 = tslib_1.__values(sessionFactories), sessionFactories_1_1 = sessionFactories_1.next();
                    _d.label = 3;
                case 3:
                    if (!!sessionFactories_1_1.done) return [3 /*break*/, 13];
                    factory = sessionFactories_1_1.value;
                    return [4 /*yield*/, factory()];
                case 4:
                    session = _d.sent();
                    return [4 /*yield*/, expect(storage.storeSession(session)).resolves.toBe(true)];
                case 5:
                    _d.sent();
                    _a = expect;
                    _b = session_utils_1.sessionEqual;
                    return [4 /*yield*/, storage.loadSession(sessionId)];
                case 6:
                    _a.apply(void 0, [_b.apply(void 0, [_d.sent(), session])]).toBe(true);
                    return [4 /*yield*/, expect(storage.storeSession(session)).resolves.toBe(true)];
                case 7:
                    _d.sent();
                    return [4 /*yield*/, storage.loadSession(sessionId)];
                case 8:
                    loadedSession = _d.sent();
                    expect((0, session_utils_1.sessionEqual)(loadedSession, session)).toBe(true);
                    expect(loadedSession === null || loadedSession === void 0 ? void 0 : loadedSession.isActive()).toBe(true);
                    return [4 /*yield*/, expect(storage.deleteSession(sessionId)).resolves.toBe(true)];
                case 9:
                    _d.sent();
                    return [4 /*yield*/, expect(storage.loadSession(sessionId)).resolves.toBeUndefined()];
                case 10:
                    _d.sent();
                    // Deleting a non-existing session should work
                    return [4 /*yield*/, expect(storage.deleteSession(sessionId)).resolves.toBe(true)];
                case 11:
                    // Deleting a non-existing session should work
                    _d.sent();
                    _d.label = 12;
                case 12:
                    sessionFactories_1_1 = sessionFactories_1.next();
                    return [3 /*break*/, 3];
                case 13: return [3 /*break*/, 16];
                case 14:
                    e_1_1 = _d.sent();
                    e_1 = { error: e_1_1 };
                    return [3 /*break*/, 16];
                case 15:
                    try {
                        if (sessionFactories_1_1 && !sessionFactories_1_1.done && (_c = sessionFactories_1.return)) _c.call(sessionFactories_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                    return [7 /*endfinally*/];
                case 16: return [2 /*return*/];
            }
        });
    }); });
    it('can store sessions with unexpected fields', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var storage, sessionId, session, _a, _b;
        return tslib_1.__generator(this, function (_c) {
            switch (_c.label) {
                case 0: return [4 /*yield*/, storageFactory()];
                case 1:
                    storage = _c.sent();
                    sessionId = 'test_session';
                    session = new session_1.Session(sessionId, 'shop', 'state', true);
                    session.someField = 'lol';
                    return [4 /*yield*/, expect(storage.storeSession(session)).resolves.toBe(true)];
                case 2:
                    _c.sent();
                    _a = expect;
                    _b = session_utils_1.sessionEqual;
                    return [4 /*yield*/, storage.loadSession(sessionId)];
                case 3:
                    _a.apply(void 0, [_b.apply(void 0, [_c.sent(), session])]).toBe(true);
                    return [2 /*return*/];
            }
        });
    }); });
    it('can store and delete sessions with online tokens', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var storage, sessionId, session, _a, _b;
        return tslib_1.__generator(this, function (_c) {
            switch (_c.label) {
                case 0: return [4 /*yield*/, storageFactory()];
                case 1:
                    storage = _c.sent();
                    sessionId = 'test_session';
                    session = new session_1.Session(sessionId, 'shop', 'state', true);
                    return [4 /*yield*/, expect(storage.storeSession(session)).resolves.toBe(true)];
                case 2:
                    _c.sent();
                    _a = expect;
                    _b = session_utils_1.sessionEqual;
                    return [4 /*yield*/, storage.loadSession(sessionId)];
                case 3:
                    _a.apply(void 0, [_b.apply(void 0, [_c.sent(), session])]).toBe(true);
                    return [2 /*return*/];
            }
        });
    }); });
    it('wrong ids return null sessions', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var storage;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, storageFactory()];
                case 1:
                    storage = _a.sent();
                    return [4 /*yield*/, expect(storage.loadSession('not_a_session_id')).resolves.toBeUndefined()];
                case 2:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    }); });
    it('can find all the sessions for a given shop', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var storage, prefix, sessions, sessions_1, sessions_1_1, session, e_2_1, shop1Sessions;
        var e_2, _a;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, storageFactory()];
                case 1:
                    storage = _b.sent();
                    prefix = 'find_sessions';
                    sessions = [
                        new session_1.Session("".concat(prefix, "_1"), 'find-shop1-sessions', 'state', true),
                        new session_1.Session("".concat(prefix, "_2"), 'do-not-find-shop2-sessions', 'state', true),
                        new session_1.Session("".concat(prefix, "_3"), 'find-shop1-sessions', 'state', true),
                        new session_1.Session("".concat(prefix, "_4"), 'do-not-find-shop3-sessions', 'state', true),
                    ];
                    _b.label = 2;
                case 2:
                    _b.trys.push([2, 7, 8, 9]);
                    sessions_1 = tslib_1.__values(sessions), sessions_1_1 = sessions_1.next();
                    _b.label = 3;
                case 3:
                    if (!!sessions_1_1.done) return [3 /*break*/, 6];
                    session = sessions_1_1.value;
                    return [4 /*yield*/, expect(storage.storeSession(session)).resolves.toBe(true)];
                case 4:
                    _b.sent();
                    _b.label = 5;
                case 5:
                    sessions_1_1 = sessions_1.next();
                    return [3 /*break*/, 3];
                case 6: return [3 /*break*/, 9];
                case 7:
                    e_2_1 = _b.sent();
                    e_2 = { error: e_2_1 };
                    return [3 /*break*/, 9];
                case 8:
                    try {
                        if (sessions_1_1 && !sessions_1_1.done && (_a = sessions_1.return)) _a.call(sessions_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                    return [7 /*endfinally*/];
                case 9:
                    expect(storage.findSessionsByShop).toBeDefined();
                    if (!storage.findSessionsByShop) return [3 /*break*/, 11];
                    return [4 /*yield*/, storage.findSessionsByShop('find-shop1-sessions')];
                case 10:
                    shop1Sessions = _b.sent();
                    expect(shop1Sessions).toBeDefined();
                    if (shop1Sessions) {
                        expect(shop1Sessions.length).toBe(2);
                        expect((0, session_test_utils_1.sessionArraysEqual)(shop1Sessions, [
                            sessions[0],
                            sessions[2],
                        ])).toBe(true);
                    }
                    _b.label = 11;
                case 11: return [2 /*return*/];
            }
        });
    }); });
    it('can delete the sessions for a given array of ids', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var storage, prefix, sessions, sessions_2, sessions_2_1, session, e_3_1, shop1Sessions, idsToDelete;
        var e_3, _a;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, storageFactory()];
                case 1:
                    storage = _b.sent();
                    prefix = 'delete_sessions';
                    sessions = [
                        new session_1.Session("".concat(prefix, "_1"), 'delete-shop1-sessions', 'state', true),
                        new session_1.Session("".concat(prefix, "_2"), 'do-not-delete-shop2-sessions', 'state', true),
                        new session_1.Session("".concat(prefix, "_3"), 'delete-shop1-sessions', 'state', true),
                        new session_1.Session("".concat(prefix, "_4"), 'do-not-delete-shop3-sessions', 'state', true),
                    ];
                    _b.label = 2;
                case 2:
                    _b.trys.push([2, 7, 8, 9]);
                    sessions_2 = tslib_1.__values(sessions), sessions_2_1 = sessions_2.next();
                    _b.label = 3;
                case 3:
                    if (!!sessions_2_1.done) return [3 /*break*/, 6];
                    session = sessions_2_1.value;
                    return [4 /*yield*/, expect(storage.storeSession(session)).resolves.toBe(true)];
                case 4:
                    _b.sent();
                    _b.label = 5;
                case 5:
                    sessions_2_1 = sessions_2.next();
                    return [3 /*break*/, 3];
                case 6: return [3 /*break*/, 9];
                case 7:
                    e_3_1 = _b.sent();
                    e_3 = { error: e_3_1 };
                    return [3 /*break*/, 9];
                case 8:
                    try {
                        if (sessions_2_1 && !sessions_2_1.done && (_a = sessions_2.return)) _a.call(sessions_2);
                    }
                    finally { if (e_3) throw e_3.error; }
                    return [7 /*endfinally*/];
                case 9:
                    expect(storage.deleteSessions).toBeDefined();
                    if (!(storage.deleteSessions && storage.findSessionsByShop)) return [3 /*break*/, 13];
                    return [4 /*yield*/, storage.findSessionsByShop('delete-shop1-sessions')];
                case 10:
                    shop1Sessions = _b.sent();
                    expect(shop1Sessions).toBeDefined();
                    if (!shop1Sessions) return [3 /*break*/, 13];
                    expect(shop1Sessions.length).toBe(2);
                    idsToDelete = shop1Sessions.map(function (session) { return session.id; });
                    return [4 /*yield*/, expect(storage.deleteSessions(idsToDelete)).resolves.toBe(true)];
                case 11:
                    _b.sent();
                    return [4 /*yield*/, storage.findSessionsByShop('delete-shop1-sessions')];
                case 12:
                    shop1Sessions = _b.sent();
                    expect(shop1Sessions).toEqual([]);
                    _b.label = 13;
                case 13: return [2 /*return*/];
            }
        });
    }); });
}
exports.batteryOfTests = batteryOfTests;
